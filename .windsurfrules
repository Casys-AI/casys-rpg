üé≤ CASYS RPG - ARCHITECTURE ET TECHNOLOGIES

ARCHITECTURE GLOBALE

Syst√®me d'Agents
Architecture multi-agents bas√©e sur LangChain / langgraph

Cinq agents sp√©cialis√©s :

StoryGraph : Gestion du workflow et des transitions d'√©tat
RulesAgent : Analyse et interpr√©tation des r√®gles du jeu
DecisionAgent : Gestion de la logique d√©cisionnelle
NarratorAgent : Pr√©sentation et formatage du contenu
TraceAgent : Gestion de l'historique des actions et des statistiques du personnage
Communication :

Configuration hi√©rarchique √† plusieurs niveaux :
GameConfig : Configuration principale du jeu
AgentConfigs : Configurations sp√©cifiques pour chaque agent
ManagerConfigs : Configurations pour les managers
StorageConfig : Configuration du stockage

Gestionnaires (Managers)

Managers Principaux :
AgentManager : Coordinateur de haut niveau
Gestion des interactions utilisateur
Coordination de l'√©tat du jeu
Gestion des erreurs
Gestion des sessions

Managers d'√âtat et Cache :
StateManager : Gestion de l'√©tat du jeu
CacheManager : Gestion du cache en m√©moire
Managers de Contenu :
RulesManager : Gestion des r√®gles du jeu
NarratorManager : Gestion du contenu narratif
DecisionManager : Gestion des d√©cisions
CharacterManager : Gestion des personnages
TraceManager : Gestion de l'historique
Infrastructure :
FilesystemAdapter : Gestion des acc√®s fichiers

Orchestration via LangGraph (StateGraph)
Coordination centralis√©e par StoryGraph
Communication asynchrone (AsyncGenerator)
Le StoryGraph est en fait l'agent principal qui orchestre le workflow du jeu Il g√®re :

Les transitions d'√©tat
L'ex√©cution du workflow principal
La coordination entre les autres agents
La gestion des erreurs

Gestion d'√âtat
Syst√®me d'√©tat immutable avec validation Pydantic v2
Tra√ßabilit√© compl√®te des actions et d√©cisions
Gestion des √©v√©nements asynchrones
Cache en m√©moire pour les performances
Moteur de R√®gles
Syst√®me de cache en m√©moire pour les r√®gles
Analyse LLM (gpt-4o-mini) pour l'interpr√©tation
Syst√®me de d√©s contextuel (chance et combat)
Validation des conditions en temps r√©el
Stockage des r√®gles en format Markdown


TECHNOLOGIES UTILIS√âES

FastAPI : API REST et WebSocket
Pydantic v2 : Validation de donn√©es et s√©rialisation
LangGraph : Orchestration des agents
OpenAI API (gpt-4o-mini) : Mod√®le de langage
AsyncIO : Gestion asynchrone

Frontend
Qwik : Framework web moderne et performant




Bonnes pratiques et subtilit√©s pour Qwik :
Optimisation et $:

Toujours suffixer les fonctions avec $ pour le lazy-loading.
Utiliser $() uniquement lorsque n√©cessaire pour encapsuler une logique.
Pr√©f√©rer inlinedQrl() pour les cas avanc√©s de cr√©ation de QRL.
R√©activit√© :

Utiliser useSignal pour g√©rer des valeurs primitives r√©actives.
Utiliser useStore pour des objets complexes r√©actifs.
Surveiller les changements avec track() dans useTask$.
Lifecycle :

useTask$ pour r√©agir aux changements r√©actifs.
useVisibleTask$ pour ex√©cuter du code lorsque le composant est visible.
Routing :

Utiliser routeLoader$ pour charger des donn√©es avant le rendu.
Utiliser routeAction$ pour g√©rer des actions c√¥t√© serveur.
Exploiter le composant <Form> pour lier facilement des actions √† un formulaire.
Lazy-loading :

D√©couper les composants avec component$.
Charger dynamiquement les sous-composants via lazy$.
WebSockets et √©v√©nements :

G√©rer les callbacks WebSocket avec $ pour qu'ils soient optimis√©s.
Utiliser cleanup() dans useTask$ pour nettoyer les connexions.
Structure des fichiers :

Respecter la convention des r√©pertoires (routes, components, services, etc.).
Placer les loaders et actions directement dans les fichiers de route.
Debugging et logs :

Activer les logs en d√©veloppement pour v√©rifier les optimisations.
Toujours tester l'int√©gration des fonctions optimis√©es.
Gestion des erreurs :

Traiter les erreurs dans routeLoader$ et routeAction$.
Afficher des messages d'erreur dans l'UI en cas de probl√®mes.
Performance :

Limiter les d√©pendances suivies par track() aux variables n√©cessaires.
Supprimer les fonctions inutiles de $.
Mise √† jour :

Utiliser les derni√®res versions de Qwik et v√©rifier la compatibilit√© des plugins.
SEO :

Configurer DocumentHead pour g√©rer les m√©tadonn√©es SEO.
Pr√©f√©rer le rendu statique lorsque possible.
Configuration :

Utiliser qwikVite pour configurer correctement l'optimiseur.
Activer le mode SSR pour des performances accrues.


